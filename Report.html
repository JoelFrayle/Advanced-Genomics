---
title: "Report Advanced Genomics"
author: "Joel Frayle Moreno- Francesco Mazza"
date: "2026-02-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Project number 5: DNA replication introduces copy number variations that are detectable in RNA-seq

We have to install and run the required packages:

```{r packages}
#install.packages('lubridate')
pkgs <- c("dplyr","data.table","stringr","scales","tibble")
for (p in pkgs) if (!requireNamespace(p, quietly=TRUE)) install.packages(p)
library(dplyr); library(data.table); library(stringr); library(scales); library(tibble)
```

## File Handling 

First we read the datasets and then we explore them. 
expr_df is a collection of gene expression data for E. Coli generated through single cell RNA-seq analysis, and have been already normalized with logarithmic function; each colname represents the experiments, and the rownames represent the genes_identifier;
meta_df instead contains all the metadata related to each sample;


```{r file reading }

expr_df <- read.csv("log_tpm.csv", check.names = FALSE)  # first col = gene_id
meta_df <- read.csv("sample_table.csv", check.names = FALSE)
colnames(expr_df)[1:10]
colnames(meta_df)[1:10]
```

## Mapping
We retrieve the information from NCBI that give us the Genes, and the position in a lineal sequence. This is going to help us later to set the position of each one of the genes in our dataset.

```{r mapping }
gff_url  <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.gff.gz"
gff_file <- "GCF_000005845.2_ASM584v2_genomic.gff.gz"
if (!file.exists(gff_file)) download.file(gff_url, gff_file, mode="wb")
gff <- fread(gff_file, sep="\t", header=FALSE, quote="", comment.char="#", fill=TRUE) #fread help us to manage the information from the NCBI File
setnames(gff, c("seqid","source","type","start","end","score","strand","phase","attr")) #We set some known names to the columns to manage more easy the
genes_main <- copy(gff)
table(gff$type) #We make some expoloration of the data in gff
```

## Extraction usefull information:
  we subset from gff, and we keep only the information for our specific case: gene_id, start and end position of each gene;
  as we need a circular chromosome, we need to compute the specific position; we set "pos" as the average of the start and end positions of each gene; 
  then we will approximate the position of each gene to these "pos" values.

```{r obtaining coordinates}
gff <- gff[type == "gene"] #We remain just with the gene information
gff[, gene_id := sub(".*locus_tag=([^;]+).*", "\\1", attr)] #We extract from the NCBI attr the identificator of the gene that correspond to the name of the gene in our dataset
seq_spans <- gff[, .(span = max(end, na.rm=TRUE) - min(start, na.rm=TRUE)), by=seqid]
main_seqid <- seq_spans[which.max(span), seqid]
genes_main <- gff[seqid == main_seqid]
gff <- gff[, .(gene_id, start, end)]
gff[, start := as.integer(start)]
gff[, end   := as.integer(end)]    #We extract the positions of the gene
typeof(gff$start)

L <- max(gff$end, na.rm=TRUE) 
#Sets L to the maximum end coordinate on the main chromosome: 
#your estimate of the genome length (useful for building circular coordinates later). 
#L should be approximately the chromosome length (e.g., ~4.6e6 for E. coli K12).
gene_coords <- gff[grepl("^b\\d{4}$", gene_id),
                          .(gene_id, start, end, pos=(start+end)/2)]
gene_coords <- unique(gene_coords, by="gene_id")
head(gene_coords)
```


## Map expression matrix to genes with coords

We have to make some sanity checks as looking if we have in our dataset one gene more than once. At the end of this block we have "gene_info" with the position, and "expr_mat2" with the expression organized to match the order in "gene_info"

```{r Map expression matrix to genes with coords }
expr_gene_id <- expr_df[[1]] #Expression values themselves have no genomic meaning unless you know which gene each row corresponds to. So we extract the genes id of our dataset.
#This vector becomes the backbone for joining expression ‚Üî coordinates
anyDuplicated(expr_gene_id) #In our sanity check we have not repeated genes.
#‚Äútake genes in expression order, then attach coordinates if available.‚Äù
#We create then "gene_info", that contains the genes of our dataset with its respective position.
gene_info <- tibble(gene_id = expr_gene_id) %>%
  left_join(as.data.frame(gene_coords) %>% mutate(gene_id=as.character(gene_id)),
            by="gene_id")


expr_mat <- as.matrix(expr_df[, -1]) #We transform our data into a matrix to apply it in the linear model.
rownames(expr_mat) <- expr_df[[1]]
storage.mode(expr_mat) <- "numeric"
expr_mat2 <- expr_mat[gene_info$gene_id, , drop=FALSE] #We organize our matrix to keep only rows corresponding to genes with coordinates, reorders it to match exactly the order of gene_info.
head(expr_mat2[, 1:6, drop=FALSE])
```

## Genes grouped by Bins
As suggested by the assignment, we divided the circular genome into fixed-size windows of 100 kb length;
  each window is a bin; 
   We have 46 bins, according to the total length of the Coli Genome;
  We then assign each gene to a bin based on its genomic position;
for each bin, we computed a single angular coordinate (theta);
So in the future we can model expression as a sinusoid over the genome.  
  y = Œ± + Œ≤ cos(Œ∏) + Œ≥ sin(Œ∏)
  
```{r bin definition }
window_size <- 100000
#E. coli genome ‚âà 4.6 Mb ‚Üí ~46 bins This is a tradeoff:
   #Smaller bins ‚Üí noisier but higher resolution
   #Larger bins ‚Üí smoother but may wash out signal
L / window_size    #46.41628
gene_info <- gene_info %>%
  mutate(
    pos_mod   = pos %% L,
    bin       = floor(pos_mod / window_size),
    bin_mid   = ((bin + 0.5) * window_size) %% L,
    theta_bin = 2*pi*bin_mid/L
  )
#y = Œ± + Œ≤ cos(Œ∏) + Œ≥ sin(Œ∏)

idx_by_bin <- split(seq_len(nrow(gene_info)), gene_info$bin)
n_genes_in_window <- sapply(idx_by_bin, length)
# this counts how many genes are in each bin;
# 0  1  2  3  4  5 
#86 85 97 88 93 89 

theta_by_bin <- gene_info %>%
  distinct(bin, theta_bin) %>%
  mutate(bin = as.integer(bin)) %>%
  arrange(bin)
```

## Mean logTPM per bin per sample

Now we have to aggregate the gene expression into bin expression. So at the end of this step we will have a long format with the bin, the sample, the mean expression (we can perform this mean directly due to the fact that the data is already in logaritmic form), the position in angular coordinate and the number of genes in each window. In this way, if necessary, we can easily apply a weighting.
```{r Bin Expression}
y_bin_mat <- sapply(idx_by_bin, function(idx) {
  colMeans(expr_mat2[idx, , drop=FALSE], na.rm=TRUE)
}) #Here we build our dataset with the average expression for each bin. 
y_bin_mat <- t(y_bin_mat)  # And as we want to mantain the order we use the transpose so we have in the columns the experiments and in the lines the bin.
bins <- as.integer(names(idx_by_bin)) #Its easier to use the bins as an integer in the future

bin_expr <- data.frame(
  bin       = rep(bins, times = ncol(y_bin_mat)),
  sample_id = rep(colnames(y_bin_mat), each = length(bins)),
  y         = as.vector(y_bin_mat)
) %>%
  left_join(theta_by_bin, by="bin") %>%
  mutate(n_genes = rep(as.integer(n_genes_in_window), times=ncol(y_bin_mat))) #Here we have our output for the model. With the long format required

head(bin_expr)
```

## Fit circular model per sample
For each sample, we fit a null model (fit0) that assumes constant expression across the genome (y=Œ±), we will use this later to compare if using circular model (y = Œ± + Œ≤ cos(Œ∏) + Œ≥ sin(Œ∏)) improves it significantly the fit.

We parametrized the circular model using sine and cosine basis functions, allowing the sinusoidal pattern to be estimated within a linear regression framework. This avoids nonlinear optimization ($y = \alpha + A *Cos(\theta-\phi) $) over amplitude and phase parameters.

The non linear model starts by representing the bin as follows:
$$A(\cos(\theta-\phi))=A\cos(\theta)\cos(\phi)+A\sin(\theta)\sin(\phi)$$
We defined:S
$$\beta = A\cos{\phi}$$
$$\gamma=A\sin(\phi)$$
With this transformation we represent the same model with a different parameterization. From the previous analysis we can set as useful information that:
$$A=\sqrt{\beta^2+\gamma^2}$$
That give us the amplitude And:
$$\phi=\operatorname{atan2}(\gamma, \beta)$$
That give us the phase, so the position in the circular chromosome in dependence of $\gamma$ and $\beta$.
We at this point can use also a theoretical treatment that define the phase duration as C= DNA synthesis phase and D= predivisional phase. The doubling time is $\tau = \frac{2}{growthrate}$ and the position of a locus is $n_a= 2^{\frac{p_aC+D}{\tau}}$ where $n_a$ is the copy number of locus $a$ positioned at a distance $p_a$ from the terminus of the chromosome. Due to this we can arrive that: $$log_2\frac{n_{ori}}{n_{ter}}=\frac{C}{\tau}=\frac{C\mu}{ln(2)}$$

In our case we can say that, if expression is proportional to copy number, then in $log_2$ space the difference between maximal and minimal expression across the chromosome corresponds to:
$$y_{max}-y_{min}=2A=\delta$$
Thus, the fitted amplitude A provides a quantitative estimate of the replication-associated expression gradient.
We can retrive the position due to the fact that we have $\phi$, where the expression is maximum and minimum in radiants;
to apply the model to all the samples, we used the fit_one_sample function that we've just created. This function operates on one sample's binned data, so in the "results" variable for each sample, there are all the parameters of the fitted model explained above.  
In order to evaluate if there is statistical evidence to reject the null model "fit0", we used an anova F test to compute p value (p_full), then corrected with BH method for multiple testing correction (q_full)
```{r Model}
fit_one_sample <- function(df, use_weights=TRUE) {
  w <- if (use_weights) df$n_genes else NULL
  
  fit0    <- lm(y ~ 1, data=df, weights=w)
  fitFull <- lm(y ~ cos(theta_bin) + sin(theta_bin), data=df, weights=w)
  
  # Reduced models (for later comparison)
  fitCos <- lm(y ~ cos(theta_bin), data=df, weights=w)
  fitSin <- lm(y ~ sin(theta_bin), data=df, weights=w)
  
  p_full <- anova(fit0, fitFull)$`Pr(>F)`[2]
  p_cos  <- anova(fit0, fitCos )$`Pr(>F)`[2]
  p_sin  <- anova(fit0, fitSin )$`Pr(>F)`[2]
  
  coefs <- coef(summary(fitFull))
  alpha <- coefs["(Intercept)", "Estimate"]
  beta  <- coefs["cos(theta_bin)", "Estimate"]
  gamma <- coefs["sin(theta_bin)", "Estimate"]
  
  # amplitude/phase representation:
  # y(theta) = alpha + A cos(theta - phi)
  A     <- sqrt(beta^2 + gamma^2)
  phi   <- atan2(gamma, beta)              # [-pi, pi]
  delta <- 2*A                              # naive: max-min in log space
  
  theta_max <- (phi %% (2*pi))             # where cos(theta-phi) is max
  theta_min <- (theta_max + pi) %% (2*pi)
  
  tibble(alpha, beta, gamma, A, phi, delta, theta_max, theta_min, p_full, p_cos, p_sin)
}

results <- bin_expr %>%
  group_by(sample_id) %>%
  group_modify(~ fit_one_sample(.x, use_weights=TRUE)) %>%
  ungroup() %>%
  mutate(
    q_full = p.adjust(p_full, method="BH"),
    q_cos  = p.adjust(p_cos,  method="BH"),
    q_sin  = p.adjust(p_sin,  method="BH")
  ) %>%
  as_tibble()

sig_q <- !is.na(results$q_full) & results$q_full < 0.05
head(results)
```
## Visual Data exploration
The histogram shows the distribution of amplitude values across all samples. Most amplitudes cluster at low values, and the distribution is clearly right-skewed, with a long tail toward larger amplitudes. The rug marks indicate where significant fits (`q_full < 0.05`) fall along the x-axis: they are sparse at very low amplitudes and become increasingly frequent as amplitude increases, concentrating mainly in the upper part of the distribution.

This scatter plot shows the fitted $\beta$ (cosine component) against $\gamma$ (sine component) across samples, with points colored by `q_full`. The cloud is densest near the origin, indicating that most samples have small estimated coefficients. As expected, the most significant fits concentrate away from (0,0), while points near the origin are predominantly non-significant. The distribution is not isotropic: the sample cloud is elongated along a negative diagonal, suggesting that $\beta$ and $\gamma$ may not be independent in practice and tend to co-vary with opposite signs in many samples.

How are these significant values distributed? In the $(\beta,\gamma)$ plane, significant samples are primarily enriched at larger distances from the origin (equivalently, larger $A$), indicating that significance largely tracks effect size. In our data, the median $A$ increases from 0.0859 in non-significant samples to 0.214 in significant samples (`q_full < 0.05`; Wilcoxon p-value $= 5.89\times10^{-38}$). To assess whether there is also a preferred direction (i.e., a consistent peak location across samples), we examine the angular distribution (`phi`) among significant samples; the resulting histogram shows clear clustering rather than a uniform spread, suggesting that many significant samples share similar peak directions.

What happens if the models account only for the cosine or only for the sine term? The reduced models typically retain significance only for samples whose signal is sufficiently aligned with that single basis term. In our dataset, the full model identifies 95 significant samples, whereas the cosine-only and sine-only models identify 24 and 39, respectively. Importantly, 37 samples are significant under the full model but not under either reduced model, consistent with signals that require both sine and cosine terms (i.e., peak directions not aligned with a single basis). Conversely, only 5 samples are significant under the sine-only model but not under the full model, which is consistent with borderline cases where the 1-df reduced model can be slightly more powerful than the 2-df full model.

What does the estimated parameter mean? The pair $(\beta,\gamma)$ jointly encodes magnitude and direction: the distance to the origin reflects effect size (strength of the fitted pattern), while the angle (`phi`) reflects where along the circle the maximum/minimum occurs. Therefore, points farther from (0,0) correspond to stronger fitted patterns, while different quadrants/angles correspond to different peak positions.

Do you think one can derive a quantitative relationship of the parameter from the model and the growth rate? Under the replication-driven assumptions, larger effect sizes (e.g., $A$ or $2A$) should tend to be associated with higher growth rate $\mu$.
}
Overall, these comparisons support using q_full as the primary significance criterion in the remainder of the analysis. The full model is phase-invariant (it captures signal regardless of whether it aligns with the cosine or sine basis) and therefore detects substantially more significant samples than either reduced model (95 vs 24/39). The presence of many ‚Äòfull-only‚Äô cases (37 samples significant only under q_full) indicates that restricting to a single basis term would miss a large fraction of signals whose peak direction is not aligned with that term. While a small number of borderline cases can be recovered by a 1-df reduced model (5 samples significant only under q_sin), the overall gain in sensitivity and robustness makes q_full the most appropriate and conservative choice for downstream analyses.
```{r Plot, echo=FALSE}
col_q_fun <- scales::col_numeric(palette=c("red","blue"), domain=c(0,1), na.color="grey80")
pt_col <- col_q_fun(pmin(pmax(results$q_full, 0), 1))


hist(results$A, breaks=50, main="Amplitude A (all samples)", xlab="A",
       col="grey90", border="grey60")
rug(results$A, col="grey60")
rug(results$A[sig_q], col="red", lwd=2)
legend("topright",
         legend=c("All","q_full<0.05"),
         col=c("grey60","red"), lwd=c(1,2), bty="n")

plot(results$beta, results$gamma,
       xlab="beta (cos)", ylab="gamma (sin)",
       main="beta vs gamma (colored by q_full)",
       pch=16, col=pt_col, cex=ifelse(sig_q, 1.2, 0.7))
  abline(h=0, v=0, lty=3)
  points(results$beta[sig_q], results$gamma[sig_q],
         pch=21, bg=pt_col[sig_q], col="black", cex=1.25)

sig_full <- !is.na(results$q_full) & results$q_full < 0.05
sig_cos  <- !is.na(results$q_cos)  & results$q_cos  < 0.05
sig_sin  <- !is.na(results$q_sin)  & results$q_sin  < 0.05

# Effect size enrichment: significant samples have larger A
w_test <- wilcox.test(results$A ~ sig_full)

A_summary <- tibble(
  group = c("non-significant (q_full >= 0.05)", "significant (q_full < 0.05)"),
  median_A = c(median(results$A[!sig_full], na.rm=TRUE),
               median(results$A[sig_full],  na.rm=TRUE))
)

wilcox_summary <- tibble(
  test = "Wilcoxon rank-sum test: A ~ (q_full < 0.05)",
  p_value = w_test$p.value
)

# Full vs reduced models: counts and overlap structure
overlap_summary <- tibble(
  category = c("Significant (full model): q_full < 0.05",
               "Significant (cos-only): q_cos < 0.05",
               "Significant (sin-only): q_sin < 0.05",
               "Full-only: q_full < 0.05 AND q_cos >= 0.05 AND q_sin >= 0.05",
               "Sin-only not full: q_sin < 0.05 AND q_full >= 0.05"),
  n = c(sum(sig_full, na.rm=TRUE),
        sum(sig_cos,  na.rm=TRUE),
        sum(sig_sin,  na.rm=TRUE),
        sum(sig_full & !sig_cos & !sig_sin, na.rm=TRUE),
        sum(sig_sin & !sig_full, na.rm=TRUE))
)

# Compact overlap tables, but labeled so they are self-explanatory when printed
tab_full_cos <- table(`Full significant (q_full<0.05)` = sig_full,
                      `Cos-only significant (q_cos<0.05)` = sig_cos)

tab_full_sin <- table(`Full significant (q_full<0.05)` = sig_full,
                      `Sin-only significant (q_sin<0.05)` = sig_sin)

# Directionality: wrap phi to [0, 2pi) to avoid the ¬±pi boundary split
phi_02pi <- (results$phi %% (2*pi))

# Print outputs (labeled, so no guessing)
A_summary
wilcox_summary
overlap_summary
tab_full_cos
tab_full_sin

hist(phi_02pi[sig_full], breaks=30,
     main="phi distribution (significant only, wrapped to [0, 2pi))",
     xlab="phi (radians)")
```

## 9) Merge metadata
```{r Merge}

i <- which(names(meta_df) == "")[1]
names(meta_df)[i] <- "sample_id"

merged_results <- dplyr::left_join(
  results,
  dplyr::distinct(meta_df, sample_id, .keep_all = TRUE),
  by = "sample_id"
)

```

## Identification of oriC position

To anchor the circular expression model to a biologically meaningful reference point, we determined the genomic position of the replication origin (oriC). 
  In *E. coli*, the dnaA gene is located immediately adjacent to oriC and was therefore used as a proxy for the origin position. 
  The dnaA locus was identified from the genome annotation, and its midpoint was computed as:

$$\text{ori\_pos} = \frac{\text{start}_{\text{dnaA}} + \text{end}_{\text{dnaA}}}{2}.$$

This genomic coordinate was then mapped onto the circular genome using:

$$ \theta_{\text{ori}} = \frac{2\pi \cdot (\text{ori\_pos} \bmod L)}{L}, $$

where \( L \) is the chromosome length. 
  The resulting angular coordinate defines the position of oriC within the circular regression framework and enables computation of the origin‚Äìterminus expression contrast.

  
```{r theta Ori}
  ori_row <- genes_main[grepl("(^|;)gene=dnaA(;|$)|(^|;)Name=dnaA(;|$)", attr)]
if (nrow(ori_row) == 0) {
  print(head(genes_main[grepl("dnaA", attr)]$attr, 10))
  stop("dnaA not found with gene=/Name=. Inspect attr above and adjust grepl().")
}
ori_pos <- (ori_row$start[1] + ori_row$end[1]) / 2
theta_ori <- (2*pi*(ori_pos %% L))/L
cat("theta_ori (radians):", theta_ori, "\n")
``` 
## 13 Integration with measured growth rates

To evaluate the biological relevance of the inferred replication-associated expression signal, we integrated the circular model results with experimentally measured growth rates. 
  The growth-rate column was identified either manually or automatically by detecting metadata fields containing the term ‚Äúgrowth‚Äù and prioritizing those indicating rates (e.g., expressed in 1/hr). 
  The selected column was converted to numeric format for downstream analysis.
Samples lacking valid growth-rate measurements were excluded. In addition, entries with a sentinel value of 1 were removed, as this value did not represent a biologically meaningful measurement. Only samples with finite estimates of the replication metrics 
  (amplitude ùê¥ A, naive contrast  ùõø = 2 ùê¥ Œ¥=2A, and origin-aligned contrast ùõø ori Œ¥ ori ) were retained for analysis.
Significance masks were defined based on the F-test from the circular regression model, using both nominal p-values and Benjamini‚ÄìHochberg adjusted q-values (threshold 0.05).

```{r growth rate}
  detect_growth_col <- function(df) {
  cand <- names(df)[grepl("growth", tolower(names(df)))]
  if (length(cand) == 0) return(NA_character_)
  # prefer ones that look like rate (1/hr)
  cand2 <- cand[grepl("1/hr|rate", tolower(cand))]
  if (length(cand2) > 0) return(cand2[1])
  cand[1]
}

gr_col <- "Growth Rate (1/hr)"
if (!(gr_col %in% names(merged_results))) {
  auto <- detect_growth_col(merged_results)
  if (is.na(auto)) stop("Growth-rate column not found. Set gr_col manually.")
  gr_col <- auto
  cat("Auto-detected growth-rate column as:", gr_col, "\n")
}

merged_results2 <- merged_results %>%
  mutate(growth_rate = suppressWarnings(as.numeric(.data[[gr_col]])))

known <- merged_results2 %>%
  filter(!is.na(growth_rate), growth_rate != 1) %>%      # exclude sentinel "1"
  filter(is.finite(delta_ori), is.finite(delta), is.finite(A))
mask_q <- !is.na(known$q_full) & known$q_full < 0.05

``` 
## 14 Correlation analysis between replication signal and growth rate

To assess the relationship between replication-associated expression gradients and cellular growth, 
  we computed both Pearson and Spearman correlation coefficients between growth rate and the inferred replication metrics.
We first evaluated the naive amplitude-based measure, 
  
  DELTA = 2 A 

  which corresponds to the maximal difference of the fitted sinusoid. We then analyzed the origin-aligned contrast,

  VEDI EQUAZIONE 

  which specifically quantifies the fitted expression difference between the replication origin and the terminus.

Correlations were computed across all samples and separately restricted to samples exhibiting a statistically significant circular signal, 
  based on either nominal p-values or false discovery rate‚Äìadjusted q-values. Scatter plots were generated to visualize these relationships, 
  with points colored according to model significance.
This analysis provides a direct test of whether the strength of the replication-associated expression gradient predicts cellular growth rate, 
  as expected under gene-dosage effects during exponential replication.

```{r correlation}
analyze_corr <- function(df, xvar, yvar="growth_rate", title="", use_mask=NULL) {
  d <- df
  if (!is.null(use_mask)) d <- d[use_mask, , drop=FALSE]
  x <- d[[xvar]]; y <- d[[yvar]]
  
  cat("\n---", title, "---\n")
  cat("n =", sum(complete.cases(x,y)), "\n")
  cat("Pearson :", cor(x,y, use="complete.obs", method="pearson"), "\n")
  cat("Spearman:", cor(x,y, use="complete.obs", method="spearman"), "\n")
  
  cols <- col_q_fun(pmin(pmax(d$q_full, 0), 1))
  sigq <- !is.na(d$q_full) & d$q_full < 0.05
  
  plot(x, y, pch=16, col=cols,
       cex=ifelse(sigq, 1.2, 0.8),
       xlab=xvar, ylab=yvar, main=title)
  points(x[sigq], y[sigq], pch=21, bg=cols[sigq], col="black", cex=1.2)
  abline(h=0, v=0, lty=3)
}

analyze_corr(known, "delta",     title="Naive: delta=2A vs growth_rate (ALL)")
analyze_corr(known, "delta_ori", title="Corrected: delta_ori vs growth_rate (ALL)")
analyze_corr(known, "delta_ori", title="Corrected: delta_ori vs growth_rate (sig_by_p)", use_mask=mask_p)
analyze_corr(known, "delta_ori", title="Corrected: delta_ori vs growth_rate (sig_by_q)", use_mask=mask_q)
``` 
## 15 Cross-validation of predictive models

To evaluate the predictive performance of replication-associated expression metrics, we performed repeated k-fold cross-validation using linear regression models. 
    Three datasets were considered: (i) all samples with valid growth-rate measurements, (ii) samples exhibiting a statistically significant circular signal based on nominal p-values, 
    and (iii) samples significant after false discovery rate correction.
We compared multiple candidate models in which growth rate was regressed against different combinations of replication metrics, including the naive amplitude-based contrast 
ùõø = 2 ùê¥ Œ¥=2A, the origin-aligned contrast ùõø ori Œ¥ ori , the fitted amplitude  ùê¥ A, and combinations thereof.

For each dataset and model specification, we conducted repeated 5-fold cross-validation (50 repetitions). 
    In each repetition, samples were randomly partitioned into five folds; models were trained on four folds and evaluated on the held-out fold. 
    Predictions from all folds were aggregated to compute performance metrics, including:

Root Mean Squared Error (RMSE),

Mean Absolute Error (MAE),

Coefficient of determination ( ùëÖ 2 R 2 ),

Pearson and Spearman correlation between predicted and observed growth rates. 
This repeated cross-validation framework provides a robust estimate of out-of-sample predictive performance and reduces variability due to random fold assignment. 
    Model performance was summarized across repetitions, and RMSE distributions were visualized to compare competing model specifications.

```{r cross validation}

datasets <- list(
  ALL     = known,
  sig_by_p = known %>% filter(mask_p),
  sig_by_q = known %>% filter(mask_q)
)

model_specs <- list(
  m1_delta_ori      = growth_rate ~ delta_ori,
  m2_delta          = growth_rate ~ delta,
  m3_A              = growth_rate ~ A,
  m4_delta_ori_A    = growth_rate ~ delta_ori + A,
  m5_delta_ori_delta= growth_rate ~ delta_ori + delta
)

cv_repeated <- function(df, formula, k=5, R=50, seed=123) {
  set.seed(seed)
  n <- nrow(df)
  out <- vector("list", R)
  
  for (r in seq_len(R)) {
    fold_id <- sample(rep(seq_len(k), length.out=n))
    y_true <- numeric(0); y_pred <- numeric(0)
    
    for (fold in seq_len(k)) {
      train <- df[fold_id != fold, , drop=FALSE]
      test  <- df[fold_id == fold, , drop=FALSE]
      fit <- lm(formula, data=train)
      pred <- predict(fit, newdata=test)
      y_true <- c(y_true, test$growth_rate)
      y_pred <- c(y_pred, pred)
    }
    
    resid <- y_true - y_pred
    rmse <- sqrt(mean(resid^2, na.rm=TRUE))
    mae  <- mean(abs(resid), na.rm=TRUE)
    ss_res <- sum(resid^2, na.rm=TRUE)
    ss_tot <- sum((y_true - mean(y_true, na.rm=TRUE))^2, na.rm=TRUE)
    r2 <- 1 - ss_res/ss_tot
    
    out[[r]] <- tibble(
      RMSE=rmse, MAE=mae, R2=r2,
      corP=suppressWarnings(cor(y_true,y_pred, use="complete.obs", method="pearson")),
      corS=suppressWarnings(cor(y_true,y_pred, use="complete.obs", method="spearman"))
    )
  }
  bind_rows(out)
}

cv_results <- list()
for (ds_name in names(datasets)) {
  for (m_name in names(model_specs)) {
    cat("\nRunning CV:", ds_name, "|", m_name, "| n =", nrow(datasets[[ds_name]]), "\n")
    cv_results[[paste(ds_name,m_name,sep="__")]] <-
      cv_repeated(datasets[[ds_name]], model_specs[[m_name]]) %>%
      mutate(dataset=ds_name, model=m_name, n=nrow(datasets[[ds_name]]))
  }
}
cv_results_df <- bind_rows(cv_results)

cv_summary <- cv_results_df %>%
  group_by(dataset, model, n) %>%
  summarise(
    RMSE_mean=mean(RMSE), RMSE_sd=sd(RMSE),
    MAE_mean=mean(MAE),   MAE_sd=sd(MAE),
    R2_mean=mean(R2),     R2_sd=sd(R2),
    corP_mean=mean(corP, na.rm=TRUE),
    corS_mean=mean(corS, na.rm=TRUE),
    .groups="drop"
  ) %>%
  arrange(dataset, RMSE_mean)

print(cv_summary)

# RMSE boxplots
par(mfrow=c(length(datasets),1), mar=c(4,4,2,1))
for (ds_name in names(datasets)) {
  sub <- cv_results_df %>% filter(dataset==ds_name)
  boxplot(RMSE ~ model, data=sub, las=2,
          main=paste("RMSE (repeated CV) -", ds_name),
          ylab="RMSE", col="grey90", border="grey60")
}
par(mfrow=c(1,1))
```
## 16
Final model fitting
Based on cross-validation results, a final linear model was fitted using the full dataset:
growth_rate ‚àº ùõø ori . growth_rate‚àºŒ¥ ori .

In addition, a high-confidence model was fitted using only samples with a statistically significant circular signal (based on nominal p-values), 
    provided that the sample size was sufficient. In this subset, growth rate was modeled as a function of both the origin-aligned contrast and the fitted amplitude:
growth_rate ‚àº ùõø ori + ùê¥. growth_rate‚àºŒ¥ ori +A.
Model summaries were examined to assess coefficient estimates, statistical significance, and explained variance. 
    These final models provide an interpretable relationship between replication-associated expression gradients and cellular growth rate.

    ```{r final model fitting}

fit_all <- lm(growth_rate ~ delta_ori, data=datasets$ALL)

# "High-confidence" model: prefer sig_by_p due to larger n than sig_by_q
fit_hp  <- NULL
if (nrow(datasets$sig_by_p) >= 20) {
  fit_hp <- lm(growth_rate ~ delta_ori + A, data=datasets$sig_by_p)
}

cat("\n--- fit_all summary ---\n"); print(summary(fit_all))
if (!is.null(fit_hp)) { cat("\n--- fit_hp summary (sig_by_p) ---\n"); print(summary(fit_hp)) }
```
## 17


  ```{r packages}
#install.packages('lubridate')
pkgs <- c("dplyr","data.table","stringr","scales","tibble")
for (p in pkgs) if (!requireNamespace(p, quietly=TRUE)) install.packages(p)
library(dplyr); library(data.table); library(stringr); library(scales); library(tibble)
```

## 18



  ```{r packages}
#install.packages('lubridate')
pkgs <- c("dplyr","data.table","stringr","scales","tibble")
for (p in pkgs) if (!requireNamespace(p, quietly=TRUE)) install.packages(p)
library(dplyr); library(data.table); library(stringr); library(scales); library(tibble)
```
## 19



  ```{r packages}
#install.packages('lubridate')
pkgs <- c("dplyr","data.table","stringr","scales","tibble")
for (p in pkgs) if (!requireNamespace(p, quietly=TRUE)) install.packages(p)
library(dplyr); library(data.table); library(stringr); library(scales); library(tibble)
```
## 20



  
  
